use std::fs::Permissions;
use std::os::unix::fs::PermissionsExt;
use std::str;
use std::{fs, path::Path, process::Command};

use crate::node::state::NodeState;
use anyhow::Result;
use log::{error, info};
use shared_lib::command::CommandExecutor;

use super::{super::interface::Backend, command::SystemdCommand, SystemdConfig};

const PREAMBLE: &str = "# This file is generated by wgpull, changes will be lost.\n\n";

pub struct SystemdBackend<T: CommandExecutor> {
    pub config: SystemdConfig,
    pub command: SystemdCommand<T>,
}

impl<T: CommandExecutor> SystemdBackend<T> {
    pub fn new(config: &SystemdConfig, command: SystemdCommand<T>) -> Self {
        Self {
            config: config.clone(),
            command,
        }
    }

    /// Writes the provided `contents` to a file at the specified `path` if the current contents are different.
    ///
    /// If the file does not exist or its contents differ from the provided `contents`, the file will be created or overwritten
    /// with the new contents. The file's permissions will be set to 0640 (`-rw-r-----`), the owner will be set to root, and
    /// the group will be set to "systemd-networkd".
    ///
    /// # Arguments
    ///
    /// * `path` - A reference to a Path for the file to write.
    /// * `contents` - The new contents to write to the file.
    ///
    /// # Returns
    ///
    /// This function returns an `anyhow::Result<bool>`. If the function succeeds, the boolean indicates whether the file
    /// was modified: `true` means the file was modified (or created), and `false` means the file was not modified.
    pub fn write_if_changed(path: &Path, contents: &str) -> Result<bool> {
        let contents_changed = match fs::read_to_string(path) {
            Ok(current) if current == contents => false,
            _ => {
                fs::write(path, contents)?;
                fs::set_permissions(path, Permissions::from_mode(0o640))?;
                Command::new("chown")
                    .arg("root:systemd-network")
                    .arg(path)
                    .output()?;
                true
            }
        };

        Ok(contents_changed)
    }

    pub fn get_interface_netdev_contents(&self, state: &NodeState) -> String {
        let mut content = String::new();

        content.push_str(PREAMBLE);

        content.push_str("[NetDev]\n");
        content.push_str(format!("Name = {}\n", self.config.interface).as_str());
        content.push_str("Kind = wireguard\n");
        content.push_str("Description = Wireguard Interface\n\n");

        content.push_str("[WireGuard]\n");
        content.push_str(format!("PrivateKey = {}\n", state.private_key).as_str());
        content.push_str(format!("ListenPort = {}\n\n", state.listen_port).as_str());

        for peer in &state.peers {
            content.push_str(format!("# Peer: {}\n", peer.hostname).as_str());
            content.push_str("[WireGuardPeer]\n");
            content.push_str(
                format!("Endpoint = {}:{}\n", peer.endpoint_host, peer.endpoint_port).as_str(),
            );
            content.push_str(format!("PublicKey = {}\n", peer.public_key).as_str());
            content.push_str(format!("PresharedKey = {}\n", peer.preshared_key).as_str());
            content.push_str(format!("AllowedIPs = {}\n", peer.allowed_ips.join(", ")).as_str());
            content.push_str(
                format!("PersistentKeepalive = {}\n\n", peer.persistent_keepalive).as_str(),
            );
        }

        content
    }

    pub fn get_interface_network_contents(&self, state: &NodeState) -> String {
        let mut content = String::new();

        content.push_str(PREAMBLE);

        content.push_str("[Match]\n");
        content.push_str(format!("Name = {}\n", self.config.interface).as_str());

        content.push_str("[Network]\n");
        content.push_str(format!("Address = {}\n\n", state.address).as_str());

        if state.route_allowed_ips {
            for peer in &state.peers {
                for allowed_ip in &peer.allowed_ips {
                    content.push_str(
                        format!("\n[Route]\nDestination = {}\nScope=link\n\n", allowed_ip).as_str(),
                    );
                }
            }
        }

        content
    }
}

impl<T: CommandExecutor> Backend for SystemdBackend<T> {
    fn is_compatible(&self) -> bool {
        // ignore this check, used for limited integration testing
        if std::env::var("WGPULL_IGNORE_AVAILABILITY").unwrap_or("false".to_string()) == "true" {
            return true;
        }

        // check if the systemd-networkd service is running and enabled
        if !self
            .command
            .service_is_running_and_enabled("systemd-networkd")
        {
            error!("systemd-networkd is not running or enabled");
            return false;
        }

        // make sure the network directory is present and writable (/etc/systemd/network)
        // the writable check is pretty inaccurate but it's better than nothing
        let network_dir = Path::new("/etc/systemd/network");
        if !network_dir.exists() {
            error!("systemd-networkd directory does not exist");
            return false;
        }

        if !network_dir.is_dir() {
            error!("systemd-networkd network directory is not a directory");
            return false;
        }

        true
    }

    fn update_local_state(&self, state: &NodeState) -> Result<bool> {
        info!(
            "Node systemd backend update of local state, updating with {} peers",
            state.peers.len()
        );

        let netdev_contents = self.get_interface_netdev_contents(state);
        let netdev_path =
            Path::new(&self.config.path).join(format!("{}.netdev", self.config.interface));
        let has_netdev_changed = Self::write_if_changed(&netdev_path, netdev_contents.as_ref())?;

        let network_contents = self.get_interface_network_contents(state);
        let network_path =
            Path::new(&self.config.path).join(format!("{}.network", self.config.interface));
        let has_network_changed = Self::write_if_changed(&network_path, network_contents.as_ref())?;

        if (has_netdev_changed || has_network_changed) && self.config.reload_networkd {
            if self.config.delete_interface_before_reload {
                let _ = self
                    .command
                    .delete_wireguard_interface(&self.config.interface);
            }
            self.command.networkd_reload()?;
        }

        Ok(false)
    }

    fn get_hostname(&self) -> Result<String> {
        let output = Command::new("hostname").output()?;

        Ok(str::from_utf8(&output.stdout)?.trim().to_string())
    }
}
