use anyhow::Result;
use chrono::prelude::Timelike;
use log::info;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use std::{
    collections::{hash_map::Entry, HashMap},
    sync::Arc,
    time::SystemTime,
};

use shared_lib::{
    command::CommandExecutor, file::FileAccessor, request::NodePullRequest,
    response::NodePullResponsePeer, time::CurrentTime, wg::WireguardCommand,
};

use super::peer_pair::PeerPair;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LighthouseNodeLease {
    /// Time the node was last announced or did a pull.
    pub last_seen: SystemTime,

    /// When the last rotation of node keys occurred.
    pub last_rotation: SystemTime,

    /// The node's public key.
    pub public_key: String,

    /// The hostname of the node.
    pub hostname: String,

    /// Wireguard endpoint (hostname/ip).
    pub endpoint_host: String,

    /// Wireguard endpoint port.
    pub endpoint_port: u32,

    /// Wireguard persistent keepalive interval.
    pub persistent_keepalive: u32,

    /// Wireguard allowed IPs.
    pub allowed_ips: Vec<String>,

    /// Whether or not the allowed ips should route through the wireguard interface.
    pub route_allowed_ips: bool,
}

impl LighthouseNodeLease {
    /// Compares node leases, excluding timestamps.
    pub fn compare_to(&self, other: &LighthouseNodeLease) -> bool {
        self.public_key == other.public_key
            && self.hostname == other.hostname
            && self.endpoint_host == other.endpoint_host
            && self.endpoint_port == other.endpoint_port
            && self.persistent_keepalive == other.persistent_keepalive
            && self.allowed_ips == other.allowed_ips
            && self.route_allowed_ips == other.route_allowed_ips
    }
}

#[serde_as]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LighthouseState {
    /// All known nodes in the network that are known to the lighthouse.
    pub nodes: HashMap<String, LighthouseNodeLease>,

    /// Pre-shared keys are generated by the lighthouse.
    /// It stores the association between two peer pairs and the pre-shared key.
    /// serialize as an array instead of an object
    #[serde_as(as = "Vec<(_, _)>")]
    pub preshared_keys: HashMap<PeerPair, String>,

    /// Timestamp when the lighthouse state was last modified.
    /// Keeps track of changed nodes as well as new/changed pershared key pairs.
    pub last_modified: SystemTime,
}

impl LighthouseState {
    /// Load state from a file in TOML format, if the state file is not present return None without error.
    /// Otherwise return the state or an error in case the state is corrupted or filesystem issues.
    pub async fn from_file(
        path: &str,
        accessor: &dyn FileAccessor,
    ) -> Result<Option<LighthouseState>> {
        info!("Restoring lighthouse state from {}", path);
        let contents = match accessor.read(path).await {
            Ok(contents) => contents,
            Err(_) => return Ok(None),
        };

        let state = match toml::from_str(&contents) {
            Ok(state) => state,
            Err(_) => return Err(anyhow::anyhow!("Error parsing state file.")),
        };

        Ok(Some(state))
    }

    /// Saves the state to disk in TOML format.
    pub async fn save(&self, path: &str, accessor: &dyn FileAccessor) -> Result<()> {
        info!("Saving lighthouse state to {}", path);
        // Convert the state to a TOML string.
        let content = toml::to_string(self)?;
        // Write the TOML string to the state file.
        accessor.write(path, &content).await?;
        Ok(())
    }

    /// Update or insert a node lease from a pull request.
    /// It keeps the last rotation time of the node lease, but updates the last_modified time
    /// if the node lease has changed.
    pub fn upsert_node_lease_from_pull_request(
        &mut self,
        request: &NodePullRequest,
        time: &dyn CurrentTime,
    ) {
        // get oldest last rotation in nodes:
        let last_rotation = self
            .nodes
            .values()
            .map(|node| node.last_rotation)
            .min()
            .unwrap_or_else(|| time.now());
        let new_lease = LighthouseNodeLease {
            last_seen: time.now(),
            last_rotation,
            public_key: request.public_key.clone(),
            hostname: request.hostname.clone(),
            endpoint_host: request.endpoint.clone(),
            endpoint_port: request.listen_port,
            persistent_keepalive: request.persistent_keepalive,
            allowed_ips: request.allowed_ips.clone(),
            route_allowed_ips: request.route_allowed_ips,
        };
        // update last_modified if new lease has changed or is new
        if let Some(existing_lease) = self.nodes.get(&request.hostname) {
            if existing_lease.compare_to(&new_lease) {
                self.last_modified = time.now();
            }
        } else {
            self.last_modified = time.now();
        }
        self.nodes.insert(request.hostname.clone(), new_lease);
    }

    /// Remove nodes that have not been seen in the last `expiration_seconds`.
    pub fn remove_expired_nodes(&mut self, expiration_seconds: u64, time: &dyn CurrentTime) {
        let now = time.now();
        let expired_nodes: Vec<String> = self
            .nodes
            .iter()
            .filter(|(_, node)| {
                let duration = now.duration_since(node.last_seen).unwrap();
                duration.as_secs() > expiration_seconds
            })
            .map(|(hostname, _)| hostname.clone())
            .collect();

        for hostname in expired_nodes {
            self.nodes.remove(&hostname);
        }
    }

    /// Get connected peer configuration for a node. This generates pre-shared keys on the fly.
    /// The order of the peers returned is sorted by their hostname.
    pub async fn get_peers_response_for_node(
        &mut self,
        hostname: &str,
        executor: Arc<dyn CommandExecutor>,
    ) -> Vec<NodePullResponsePeer> {
        let wireguard_command = WireguardCommand::new(executor.as_ref());

        let mut peers: Vec<NodePullResponsePeer> = Vec::new();

        for node in self.nodes.values() {
            if node.hostname != hostname {
                // create or retrieve pre-shared key for this peer pair:
                info!(
                    "Creating or retrieving pre-shared key for peer pair: {} and {}",
                    hostname, node.hostname
                );

                let preshared_key = match self
                    .preshared_keys
                    .entry(PeerPair::new(hostname.to_string(), node.hostname.clone()))
                {
                    Entry::Occupied(entry) => entry.get().clone(),
                    Entry::Vacant(entry) => {
                        let psk = wireguard_command
                            .generate_psk()
                            .await
                            .expect("Lighthouse failed to generate pre-shared key.");
                        entry.insert(psk.clone());
                        psk
                    }
                };

                peers.push(NodePullResponsePeer {
                    hostname: node.hostname.clone(),
                    public_key: node.public_key.clone(),
                    preshared_key,
                    endpoint_host: node.endpoint_host.clone(),
                    endpoint_port: node.endpoint_port,
                    allowed_ips: node.allowed_ips.clone(),
                    persistent_keepalive: node.persistent_keepalive,
                    route_allowed_ips: node.route_allowed_ips,
                });
            }
        }

        // sort peers by hostname:
        peers.sort_by(|a, b| a.hostname.cmp(&b.hostname));

        peers
    }

    /// Determines if the node should regenerate keys based on the regeneration interval and time of day.
    /// This allows to regenerate keys during the night, because there might be a short downtime of the
    /// network during the regeneration of all the keys.
    pub fn should_regenerate_keys(
        &mut self,
        hostname: &str,
        interval_seconds: u64,
        tod: (u8, u8),
        time: &dyn CurrentTime,
    ) -> Result<bool> {
        if interval_seconds == 0 {
            return Ok(false);
        }

        if let Some(node) = self.nodes.get_mut(hostname) {
            let now = time.now();
            let hour = time.now_chrono().hour() as u8;
            let duration = now.duration_since(node.last_rotation)?;

            if duration.as_secs() >= interval_seconds && (hour >= tod.0) && (hour < tod.1) {
                info!("Rotating keys for node {}.", hostname);
                node.last_rotation = now;
                return Ok(true);
            }
        }

        Ok(false)
    }
}

#[cfg(test)]
mod tests {
    use super::{LighthouseNodeLease, LighthouseState};
    use shared_lib::{request::NodePullRequest, time::CurrentTime};
    use std::{
        collections::HashMap,
        time::{Duration, SystemTime},
    };

    struct MockCurrentTime {
        now: SystemTime,
    }

    impl CurrentTime for MockCurrentTime {
        fn now(&self) -> SystemTime {
            self.now
        }
    }

    const WG_PUBKEY_1: &str = "sB4YQaiCcRpUHRa+5ziiHK2JSaznxGF+xWFSfja00Wk=";
    const WG_PUBKEY_2: &str = "KCaw+KVpzD663MNBZl4Rio/B914T5G2z0QbG8LMSBFQ=";
    const WG_PUBKEY_3: &str = "2Phnw7Nb4sAojXiSfN7UrS4uyaFRmOtBvU8MdWePwkw=";

    #[test]
    fn test_context_upsert_node_lease_from_pull_request() {
        let now = SystemTime::now();
        let ten_seconds_from_now = now
            .checked_add(Duration::from_secs(10))
            .expect("Time went backwards");

        let mut state = LighthouseState {
            nodes: HashMap::new(),
            preshared_keys: HashMap::new(),
            last_modified: now,
        };
        let mut time = MockCurrentTime { now };
        let mut node1 = NodePullRequest {
            public_key: WG_PUBKEY_1.to_string(),
            hostname: "node1".to_string(),
            endpoint: "node1".to_string(),
            listen_port: 30000,
            persistent_keepalive: 0,
            allowed_ips: vec![],
            route_allowed_ips: false,
        };

        state.upsert_node_lease_from_pull_request(&node1, &time);
        assert_eq!(state.nodes.len(), 1);
        // update listen port:
        node1.listen_port = 42;
        state.upsert_node_lease_from_pull_request(&node1, &time);
        assert_eq!(state.nodes.len(), 1);
        assert_eq!(state.nodes.get("node1").unwrap().endpoint_port, 42);

        // update last seen:
        time.now = ten_seconds_from_now;
        state.upsert_node_lease_from_pull_request(&node1, &time);
        assert_eq!(state.nodes.len(), 1);
        assert_eq!(
            state.nodes.get("node1").unwrap().last_seen,
            ten_seconds_from_now
        );
        // but keep last rotation the same:
        assert_eq!(state.nodes.get("node1").unwrap().last_rotation, now);
    }

    #[test]
    fn test_context_remove_expired_nodes() {
        let now = SystemTime::now();
        let ten_seconds_ago = now
            .checked_sub(Duration::from_secs(10))
            .expect("Time went backwards");
        let mut state = LighthouseState {
            nodes: HashMap::new(),
            preshared_keys: HashMap::new(),
            last_modified: now,
        };

        let node1 = LighthouseNodeLease {
            last_seen: now,
            last_rotation: now,
            public_key: WG_PUBKEY_1.to_string(),
            hostname: "node1".to_string(),
            endpoint_host: "node1".to_string(),
            endpoint_port: 30000,
            persistent_keepalive: 0,
            allowed_ips: vec![],
            route_allowed_ips: false,
        };
        let node2 = LighthouseNodeLease {
            last_seen: ten_seconds_ago,
            last_rotation: now,
            public_key: WG_PUBKEY_2.to_string(),
            hostname: "node1".to_string(),
            endpoint_host: "node1".to_string(),
            endpoint_port: 30000,
            persistent_keepalive: 0,
            allowed_ips: vec![],
            route_allowed_ips: false,
        };
        let node3 = LighthouseNodeLease {
            last_seen: now,
            last_rotation: now,
            public_key: WG_PUBKEY_3.to_string(),
            hostname: "node1".to_string(),
            endpoint_host: "node1".to_string(),
            endpoint_port: 30000,
            persistent_keepalive: 0,
            allowed_ips: vec![],
            route_allowed_ips: false,
        };

        state.nodes.insert("node1".to_string(), node1);
        state.nodes.insert("node2".to_string(), node2);
        state.nodes.insert("node3".to_string(), node3);

        let time = MockCurrentTime { now };

        let mut state1 = state.clone();

        // remove nodes older than the given duration (in seconds) in the past
        // node 2 is 10 seconds old, so it should be removed with a expiry of 9 seconds
        // anything older than 9 seconds gets removed...
        assert_eq!(state1.nodes.len(), 3);
        state1.remove_expired_nodes(9, &time);
        assert_eq!(state1.nodes.len(), 2);
        assert!(state1.nodes.get("node1").is_some());
        assert!(state1.nodes.get("node2").is_none());
        assert!(state1.nodes.get("node3").is_some());

        let mut state2 = state.clone();

        // anything older than 11 seconds gets removed... (removes nothing)
        assert_eq!(state2.nodes.len(), 3);
        state2.remove_expired_nodes(11, &time);
        assert_eq!(state2.nodes.len(), 3);
        assert!(state2.nodes.get("node1").is_some());
        assert!(state2.nodes.get("node2").is_some());
        assert!(state2.nodes.get("node3").is_some());
    }
}
